// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0

package sqlc

import (
	"database/sql/driver"
	"fmt"
	"time"

	"github.com/google/uuid"
)

type FeedbackAnalysisStatus string

const (
	FeedbackAnalysisStatusProcessing FeedbackAnalysisStatus = "processing"
	FeedbackAnalysisStatusSuccess    FeedbackAnalysisStatus = "success"
	FeedbackAnalysisStatusFailed     FeedbackAnalysisStatus = "failed"
)

func (e *FeedbackAnalysisStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = FeedbackAnalysisStatus(s)
	case string:
		*e = FeedbackAnalysisStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for FeedbackAnalysisStatus: %T", src)
	}
	return nil
}

type NullFeedbackAnalysisStatus struct {
	FeedbackAnalysisStatus FeedbackAnalysisStatus
	Valid                  bool // Valid is true if FeedbackAnalysisStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullFeedbackAnalysisStatus) Scan(value interface{}) error {
	if value == nil {
		ns.FeedbackAnalysisStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.FeedbackAnalysisStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullFeedbackAnalysisStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.FeedbackAnalysisStatus), nil
}

func (e FeedbackAnalysisStatus) Valid() bool {
	switch e {
	case FeedbackAnalysisStatusProcessing,
		FeedbackAnalysisStatusSuccess,
		FeedbackAnalysisStatusFailed:
		return true
	}
	return false
}

func AllFeedbackAnalysisStatusValues() []FeedbackAnalysisStatus {
	return []FeedbackAnalysisStatus{
		FeedbackAnalysisStatusProcessing,
		FeedbackAnalysisStatusSuccess,
		FeedbackAnalysisStatusFailed,
	}
}

type FeedbackSentiment string

const (
	FeedbackSentimentPositive FeedbackSentiment = "positive"
	FeedbackSentimentMixed    FeedbackSentiment = "mixed"
	FeedbackSentimentNegative FeedbackSentiment = "negative"
)

func (e *FeedbackSentiment) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = FeedbackSentiment(s)
	case string:
		*e = FeedbackSentiment(s)
	default:
		return fmt.Errorf("unsupported scan type for FeedbackSentiment: %T", src)
	}
	return nil
}

type NullFeedbackSentiment struct {
	FeedbackSentiment FeedbackSentiment
	Valid             bool // Valid is true if FeedbackSentiment is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullFeedbackSentiment) Scan(value interface{}) error {
	if value == nil {
		ns.FeedbackSentiment, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.FeedbackSentiment.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullFeedbackSentiment) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.FeedbackSentiment), nil
}

func (e FeedbackSentiment) Valid() bool {
	switch e {
	case FeedbackSentimentPositive,
		FeedbackSentimentMixed,
		FeedbackSentimentNegative:
		return true
	}
	return false
}

func AllFeedbackSentimentValues() []FeedbackSentiment {
	return []FeedbackSentiment{
		FeedbackSentimentPositive,
		FeedbackSentimentMixed,
		FeedbackSentimentNegative,
	}
}

// Predefined business topics for categorizing feedback
type FeedbackTopicEnum string

const (
	FeedbackTopicEnumProductFunctionalityFeatures     FeedbackTopicEnum = "product_functionality_features"
	FeedbackTopicEnumUiUx                             FeedbackTopicEnum = "ui_ux"
	FeedbackTopicEnumPerformanceReliability           FeedbackTopicEnum = "performance_reliability"
	FeedbackTopicEnumUsabilityProductivity            FeedbackTopicEnum = "usability_productivity"
	FeedbackTopicEnumSecurityPrivacy                  FeedbackTopicEnum = "security_privacy"
	FeedbackTopicEnumCompatibilityIntegration         FeedbackTopicEnum = "compatibility_integration"
	FeedbackTopicEnumDeveloperExperience              FeedbackTopicEnum = "developer_experience"
	FeedbackTopicEnumPricingLicensing                 FeedbackTopicEnum = "pricing_licensing"
	FeedbackTopicEnumCustomerSupportCommunity         FeedbackTopicEnum = "customer_support_community"
	FeedbackTopicEnumInstallationSetupDeployment      FeedbackTopicEnum = "installation_setup_deployment"
	FeedbackTopicEnumDataAnalyticsReporting           FeedbackTopicEnum = "data_analytics_reporting"
	FeedbackTopicEnumLocalizationInternationalization FeedbackTopicEnum = "localization_internationalization"
	FeedbackTopicEnumProductStrategyRoadmap           FeedbackTopicEnum = "product_strategy_roadmap"
)

func (e *FeedbackTopicEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = FeedbackTopicEnum(s)
	case string:
		*e = FeedbackTopicEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for FeedbackTopicEnum: %T", src)
	}
	return nil
}

type NullFeedbackTopicEnum struct {
	FeedbackTopicEnum FeedbackTopicEnum
	Valid             bool // Valid is true if FeedbackTopicEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullFeedbackTopicEnum) Scan(value interface{}) error {
	if value == nil {
		ns.FeedbackTopicEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.FeedbackTopicEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullFeedbackTopicEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.FeedbackTopicEnum), nil
}

func (e FeedbackTopicEnum) Valid() bool {
	switch e {
	case FeedbackTopicEnumProductFunctionalityFeatures,
		FeedbackTopicEnumUiUx,
		FeedbackTopicEnumPerformanceReliability,
		FeedbackTopicEnumUsabilityProductivity,
		FeedbackTopicEnumSecurityPrivacy,
		FeedbackTopicEnumCompatibilityIntegration,
		FeedbackTopicEnumDeveloperExperience,
		FeedbackTopicEnumPricingLicensing,
		FeedbackTopicEnumCustomerSupportCommunity,
		FeedbackTopicEnumInstallationSetupDeployment,
		FeedbackTopicEnumDataAnalyticsReporting,
		FeedbackTopicEnumLocalizationInternationalization,
		FeedbackTopicEnumProductStrategyRoadmap:
		return true
	}
	return false
}

func AllFeedbackTopicEnumValues() []FeedbackTopicEnum {
	return []FeedbackTopicEnum{
		FeedbackTopicEnumProductFunctionalityFeatures,
		FeedbackTopicEnumUiUx,
		FeedbackTopicEnumPerformanceReliability,
		FeedbackTopicEnumUsabilityProductivity,
		FeedbackTopicEnumSecurityPrivacy,
		FeedbackTopicEnumCompatibilityIntegration,
		FeedbackTopicEnumDeveloperExperience,
		FeedbackTopicEnumPricingLicensing,
		FeedbackTopicEnumCustomerSupportCommunity,
		FeedbackTopicEnumInstallationSetupDeployment,
		FeedbackTopicEnumDataAnalyticsReporting,
		FeedbackTopicEnumLocalizationInternationalization,
		FeedbackTopicEnumProductStrategyRoadmap,
	}
}

// Stores snapshots of AI analysis at different points in time
type FeedbackAnalysis struct {
	// Unique identifier for the analysis
	ID uuid.UUID `db:"id"`
	// Reference to the previous analysis (for incremental updates)
	PreviousAnalysisID *uuid.UUID `db:"previous_analysis_id"`
	// Start timestamp of the period covered by this analysis
	PeriodStart time.Time `db:"period_start"`
	// End timestamp of the period covered by this analysis
	PeriodEnd time.Time `db:"period_end"`
	// Total number of feedbacks included in this analysis
	FeedbackCount int32 `db:"feedback_count"`
	// Number of new feedbacks since the previous analysis
	NewFeedbackCount *int32 `db:"new_feedback_count"`
	// Human-readable summary of all feedback in this analysis
	OverallSummary string `db:"overall_summary"`
	// Overall sentiment analysis (positive/mixed/negative)
	Sentiment FeedbackSentiment `db:"sentiment"`
	// Array of key insights/takeaways from the analysis
	KeyInsights []string `db:"key_insights"`
	// LLM model used for this analysis (e.g., gpt-5-mini)
	Model string `db:"model"`
	// Total tokens consumed during analysis
	Tokens int32 `db:"tokens"`
	// Analysis duration in milliseconds
	AnalysisDurationMs int32 `db:"analysis_duration_ms"`
	// Analysis status (processing/success/failed)
	Status FeedbackAnalysisStatus `db:"status"`
	// Failure reason if analysis failed
	FailureReason *string `db:"failure_reason"`
	// Timestamp when the analysis was created
	CreatedAt time.Time `db:"created_at"`
	// Timestamp when the analysis was completed (NULL if not completed)
	CompletedAt *time.Time `db:"completed_at"`
}

// Stores topics/themes identified by AI analysis
type FeedbackAnalysisTopic struct {
	// Unique identifier for the topic
	ID uuid.UUID `db:"id"`
	// Reference to the analysis this topic belongs to
	AnalysisID uuid.UUID `db:"analysis_id"`
	// Number of feedbacks belonging to this topic
	FeedbackCount int32 `db:"feedback_count"`
	// Sentiment for this topic (positive/mixed/negative)
	Sentiment FeedbackSentiment `db:"sentiment"`
	CreatedAt time.Time         `db:"created_at"`
	UpdatedAt time.Time         `db:"updated_at"`
	// Predefined topic enum value
	TopicEnum FeedbackTopicEnum `db:"topic_enum"`
	// Summary of the analysis for this topic
	Summary string `db:"summary"`
}

// Maps feedbacks to analyses (many-to-many relationship)
type FeedbackAnalyzedFeedback struct {
	// Reference to the analysis
	AnalysisID uuid.UUID `db:"analysis_id"`
	// Reference to the feedback that was analyzed
	FeedbackID uuid.UUID `db:"feedback_id"`
	// Timestamp when the feedback was analyzed
	CreatedAt time.Time `db:"created_at"`
}

// Stores user feedback submissions with ratings and comments
type FeedbackFeedback struct {
	// Unique identifier for the feedback submission
	ID uuid.UUID `db:"id"`
	// Rating value from 1 to 5 stars
	Rating int32 `db:"rating"`
	// Free-text feedback comment (1-1000 characters)
	Comment string `db:"comment"`
	// Timestamp when the feedback was submitted
	CreatedAt time.Time `db:"created_at"`
	// Timestamp when the feedback was last updated
	UpdatedAt time.Time `db:"updated_at"`
	// Timestamp when the feedback was soft-deleted (NULL if not deleted)
	DeletedAt *time.Time `db:"deleted_at"`
	// Reference to the user who submitted the feedback
	UserID uuid.UUID `db:"user_id"`
}

// Maps feedbacks to topics (many-to-many relationship)
type FeedbackFeedbackTopicAssignment struct {
	// Unique identifier for the assignment
	ID uuid.UUID `db:"id"`
	// Reference to the analysis this assignment belongs to
	AnalysisID uuid.UUID `db:"analysis_id"`
	// Reference to the feedback being assigned
	FeedbackID uuid.UUID `db:"feedback_id"`
	// Reference to the topic being assigned to
	TopicID   uuid.UUID `db:"topic_id"`
	CreatedAt time.Time `db:"created_at"`
}

// Stores user accounts for authentication and authorization
type User struct {
	// Unique identifier for the user
	ID uuid.UUID `db:"id"`
	// User email address (unique, normalized to lowercase)
	Email string `db:"email"`
	// Hashed password (never store plain text)
	PasswordHash string `db:"password_hash"`
	// Array of user roles (e.g., ["user", "admin"])
	Roles []string `db:"roles"`
	// User account status: active, inactive, or suspended
	Status string `db:"status"`
	// Timestamp when the user account was created
	CreatedAt time.Time `db:"created_at"`
	// Timestamp when the user account was last updated
	UpdatedAt time.Time `db:"updated_at"`
	// Timestamp when the user account was soft-deleted (NULL if not deleted)
	DeletedAt *time.Time `db:"deleted_at"`
}
