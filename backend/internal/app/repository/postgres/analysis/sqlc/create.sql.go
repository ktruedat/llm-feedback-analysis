// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: create.sql

package sqlc

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const createAnalysis = `-- name: CreateAnalysis :one
INSERT INTO feedback.analyses (
    id,
    previous_analysis_id,
    period_start,
    period_end,
    feedback_count,
    new_feedback_count,
    overall_summary,
    sentiment,
    key_insights,
    model,
    tokens,
    analysis_duration_ms,
    status,
    failure_reason,
    created_at,
    completed_at
) VALUES (
    $1,  -- id
    $2,  -- previous_analysis_id (nullable)
    $3,  -- period_start
    $4,  -- period_end
    $5,  -- feedback_count
    $6,  -- new_feedback_count (nullable)
    $7,  -- overall_summary
    $8,  -- sentiment
    $9,  -- key_insights
    $10, -- model
    $11, -- tokens
    $12, -- analysis_duration_ms
    $13, -- status
    $14, -- failure_reason (nullable)
    $15, -- created_at
    $16  -- completed_at (nullable)
)
RETURNING id, previous_analysis_id, period_start, period_end, feedback_count, new_feedback_count, overall_summary, sentiment, key_insights, model, tokens, analysis_duration_ms, status, failure_reason, created_at, completed_at
`

type CreateAnalysisParams struct {
	ID                 uuid.UUID              `db:"id"`
	PreviousAnalysisID *uuid.UUID             `db:"previous_analysis_id"`
	PeriodStart        time.Time              `db:"period_start"`
	PeriodEnd          time.Time              `db:"period_end"`
	FeedbackCount      int32                  `db:"feedback_count"`
	NewFeedbackCount   *int32                 `db:"new_feedback_count"`
	OverallSummary     string                 `db:"overall_summary"`
	Sentiment          FeedbackSentiment      `db:"sentiment"`
	KeyInsights        []string               `db:"key_insights"`
	Model              string                 `db:"model"`
	Tokens             int32                  `db:"tokens"`
	AnalysisDurationMs int32                  `db:"analysis_duration_ms"`
	Status             FeedbackAnalysisStatus `db:"status"`
	FailureReason      *string                `db:"failure_reason"`
	CreatedAt          time.Time              `db:"created_at"`
	CompletedAt        *time.Time             `db:"completed_at"`
}

func (q *Queries) CreateAnalysis(ctx context.Context, arg CreateAnalysisParams) (Analysis, error) {
	row := q.db.QueryRow(ctx, createAnalysis,
		arg.ID,
		arg.PreviousAnalysisID,
		arg.PeriodStart,
		arg.PeriodEnd,
		arg.FeedbackCount,
		arg.NewFeedbackCount,
		arg.OverallSummary,
		arg.Sentiment,
		arg.KeyInsights,
		arg.Model,
		arg.Tokens,
		arg.AnalysisDurationMs,
		arg.Status,
		arg.FailureReason,
		arg.CreatedAt,
		arg.CompletedAt,
	)
	var i Analysis
	err := row.Scan(
		&i.ID,
		&i.PreviousAnalysisID,
		&i.PeriodStart,
		&i.PeriodEnd,
		&i.FeedbackCount,
		&i.NewFeedbackCount,
		&i.OverallSummary,
		&i.Sentiment,
		&i.KeyInsights,
		&i.Model,
		&i.Tokens,
		&i.AnalysisDurationMs,
		&i.Status,
		&i.FailureReason,
		&i.CreatedAt,
		&i.CompletedAt,
	)
	return i, err
}
